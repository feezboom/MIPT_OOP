13
v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13
v1 1 v7 1
v2 1 v8 2
v3 1 v1 3
v4 1 v13 4
v5 4 v3 5 v10 6 v8 7 v11 8
v6 2 v11 9 v12 10
v7 1 v5 11
v8 1 v11 12
v9 1 v6 13
v10 1 v4 14
v11 1 v2 15
v12 1 v9 16
v13 2 v10 17 v8 18
//Первый графчик на 13 вершин, нарисован в тетрадке
17
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
1 1 2
2 1 3
3 1 4
4 2 5 13
5 1 6
6 1 7
7 3 8 17 16
8 3 9 5 11
9 1 10
10 1 3
11 1 12
12 1 2
13 1 14
14 1 15
15 1 13
16 0
17 1 16
#Graph for test number #3
4
v1 v2 v3 v4
v1 1 v2
v2 2 v4 v3
v3 1 v4
v4 0
//Второй элементарный граф без сильно-связных компонент


Первое - количество вершин в графе
После в каждой строке, 
сначала имя вершины, 
потом количество вершин в которые ведет,
после эти вершины.

Алгоритмы для изучения:
	парсер джейсона json?
	struct arrays

Алгоритм Дейкстры, поиск кратчайшего пути
	У каждого ребра есть вес. 
	Релаксация?
	Найти кратчайшее рассстояние до всех вершин в графе.

Алгоритм Форда-Беллмана.
	Знаем кратчайший путь.
	делаем релаксацию для всех ребер.
	Количество раз равное диаметру графа. Если не знаем диаметр, то n-1;
	Сложность V*E.
Алгоритм Дейкстры.
	Уменьшаем число релаксаций в Форде-Беллмане.
	Итерируем по длине пути.
	Необходим поиск в ширину. 